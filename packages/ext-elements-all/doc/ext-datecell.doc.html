<!DOCTYPE HTML>
<html>
<head>
<style>

body{
  margin: 0;
  color: #fff;
}
.wrapper{
  min-height: 100vh;
  background: #ccc;
  display: flex;
  flex-direction: column;
}
.content {
  flex: 1;
  background: #999;
  display: flex;
  color: #000;
}


.heading {
    xbackground: blue;
    xpadding: 10px;
    font-size: 24px;
}

.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  flex-wrap: nowrap;
  align-items: flex-start;
  xbackground-color: DodgerBlue;
}

.flex-container > div {
  background-color: white;
  margin: 10px;
}

.thelist {
    flex-shrink: 0;
}

.thetext {
    flex-grow: 8;height: 200px;padding: 10px;
}

.theframe {
    flex-grow: 8;height: 900px;padding: 0;
}

select{
  background:transparent;
   width: 170px;
   padding: 2px;
   font-family:Arial, Helvetica, sans-serif;
   font-size:11px;
   font-weight:600;
   color:#fff;
   line-height: 1;
   border: 0;
   border-radius: 0;
   height: 22px;
  -webkit-appearance: none;

  }

.select-div{
	width: 170px;
	height: 22px;
	overflow: hidden;
	background: url(arrowhead.png) no-repeat right #363636;
	border-top:#575757 1px solid;
	-webkit-border-radius: 4px 4px 4px 4px;
	 -moz-border-radius: 4px 4px 4px 4px;
		  border-radius: 4px 4px 4px 4px;
	-webkit-box-shadow: inset 0 2px 4px rgba(107, 105, 105, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
	 -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
		  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
		  -moz-box-shadow:    0px 8px 3px -9px #000000;
		  -webkit-box-shadow: 0px 8px 3px -9px #000000;
		  box-shadow:         0px 8px 3px -9px #000000;
}

select > option {
  background: pink;
}


.frame {
    overflow-y: auto;
    border: 1px solid black;
    height: 30em;
    width: 20em;
    line-height: 1em;
}

.frame::-webkit-scrollbar {
    -webkit-appearance: none;
}

.frame::-webkit-scrollbar:vertical {
    width: 11px;
}

.frame::-webkit-scrollbar:horizontal {
    height: 11px;
}

.frame::-webkit-scrollbar-thumb {
    border-radius: 8px;
    border: 2px solid white; /* should match background, can't be transparent */
    background-color: rgba(0, 0, 0, .5);
}




.code {
    background: gainsboro;
    padding: 10px;
}

.grid-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: flex-start;
}

.grid-item {
  height: 30px;
  flex-basis: 20%;
  -ms-flex: auto;
  width: 100px;
  position: relative;
  padding: 10px;
  box-sizing: border-box;
}
.grid-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: flex-start;
}

.grid-item {
  height: 30px;
  flex-basis: 20%;
  -ms-flex: auto;
  width: 100px;
  position: relative;
  padding: 10px;
  box-sizing: border-box;
}

/* Tooltip container */
.tooltip {
  position: relative;
  display: inline-block;
  xborder-bottom: 1px dotted black; /* If you want dots under the hoverable text */
}

/* Tooltip text */
.tooltip .tooltiptext {
  visibility: hidden;
  width: 400px;
  background-color: #555;
  color: #fff;
  text-align: left;
  padding: 5px 5px 5px 5px;
  border-radius: 6px;

  /* Position the tooltip text */
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  margin-left: -60px;

  /* Fade in tooltip */
  opacity: 0;
  transition: opacity 0.3s;
}

/* Tooltip arrow */
.tooltip .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 10%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #555 transparent transparent transparent;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
</style>
<script src="z-tabs.js"></script>

</head>
<body>



<div class="wrapper">

    <section class="content">

    <z-tabs>

        <z-tabpanel tabname="overview">
            <div class="flex-container">





            </div>
        </z-tabpanel>




        <z-tabpanel tabname="usage">
            <div class="flex-container">




            </div>
        </z-tabpanel>



        <z-tabpanel tabname="properties">
            <div class="flex-container">
               align<br/>The value for the `text-align` of the cell content.
<br/><br/>
alignSelf<br/>Specifies the self alignment of this widget in a box layout
<br/><br/>
alwaysOnTop<br/>A flag indicating that this component should
be above its floated siblings.

This may be a positive number to prioritize the ordering of multiple visible always on
top components.

This may be set to a *negative* number to prioritize a component to the *bottom* of the
z-index stack.
<br/><br/>
ariaAttributes<br/>An object containing ARIA attributes to be set
on this Component's ARIA element. Use this to set the attributes that cannot be
determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.

**Note** that this config is only meaningful at the Component rendering time,
and setting it after that will do nothing.
<br/><br/>
ariaDescribedBy<br/>DOM selector for a child element that is to be used
as description for this Component, set in `aria-describedby` attribute.
The selector works the same way as {@link #cfg!ariaLabelledBy #ariaLabelledBy}.
<br/><br/>
ariaLabel<br/>ARIA label for this Component. It is best to use
{@link #cfg!ariaLabelledBy #ariaLabelledBy} option instead, because screen readers prefer
`aria-labelledby` attribute to `aria-label`. {@link #cfg!ariaLabel #ariaLabel} and
{@link #cfg!ariaLabelledBy #ariaLabelledBy} config options are mutually exclusive.
<br/><br/>
ariaLabelledBy<br/>DOM selector for a child element that is to be used
as label for this Component, set in `aria-labelledby` attribute.
If the selector is by `{@link #cfg!id #id}`, the label element can be any existing element,
not necessarily a child of the main Component element.

{@link #cfg!ariaLabelledBy #ariaLabelledBy} and {@link #cfg!ariaLabel #ariaLabel} config options are
mutually exclusive, and `{@link #cfg!ariaLabelledBy ariaLabelledBy}` has the higher precedence.
<br/><br/>
bind<br/>Setting this config option adds or removes data bindings for other configs.
For example, to bind the `title` config:

     var panel = Ext.create({
         xtype: 'panel',
         bind: {
             title: 'Hello {user.name}'
         }
     });

To dynamically add bindings:

     panel.setBind({
         title: 'Greetings {user.name}!'
     });

To remove bindings:

     panel.setBind({
         title: null
     });

The bind expressions are presented to `{@link Ext.app.ViewModel#method!bind Ext.app.ViewModel#bind}`. The
`ViewModel` instance is determined by `{@link #method!lookupViewModel lookupViewModel}`.

**Note:** If  bind is passed as a string, it will use the
{@link Ext.Component#property!defaultBindProperty Ext.Component#property-defaultBindProperty} for the binding.
<br/><br/>
bodyCls<br/>An arbitrary CSS class to add to the cell's inner element (the element that
typically contains the cell's text).
<br/><br/>
bodyStyle<br/>Additional CSS styles that will be rendered into the cell's inner element (the
element that typically contains the cell's text).

You can pass either a string syntax:

    bodyStyle: 'background:red'

Or by using an object:

    bodyStyle: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    bodyStyle: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
<br/><br/>
border<br/>Enables or disables bordering on this component.
The following values are accepted:

- `null` or `true (default): Do nothing and allow the border to be specified
by the theme.
- `false`: suppress the default border provided by the theme.

Please note that enabling bordering via this config will not add a `border-color`
or `border-style` CSS property to the component; you provide the `border-color`
and `border-style` via CSS rule or {@link #cfg!style #style} configuration
(if not already provide by the theme).

## Using {@link #cfg!style #style}:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        style: 'border: 1px solid blue;'
        // ...
    });

## Using CSS:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        cls: 'my-component'
        // ...
    });

And your CSS file:

    .my-component {
        border: 1px solid red;
    }
<br/><br/>
cellCls<br/><br/><br/>
cls<br/>An arbitrary CSS class to add to the cell's outermost element.
<br/><br/>
column<br/>The grid column that created this cell.
<br/><br/>
constrainAlign<br/>A specification of the constraint to apply when {@link #showBy} or {@link #method!alignTo #alignTo}
is called to align a {@link #cfg!floated #floated} or positioned component.

Defaults to the parent container for *positioned* components (components
which have their {@link #cfg!top}, {@link #cfg!right}, {@link #cfg!bottom} or
{@link #cfg!left} set to move them out of their container's layout flow).

Defaults to the viewport for {@link #cfg!floated #floated} components.

May be a {@link Ext.ComponentQuery} selector to find an ancestor
component to constrain within.

May be `false` to specify that constraining is not applied.

You may also specify an element, or a {@link Ext.util.Region}
<br/><br/>
controller<br/>A string alias, a configuration object or an instance of a `ViewController` for
this container. Sample usage:

    Ext.define('MyApp.UserController', {
        alias: 'controller.user'
    });

    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: 'user'
    });
    // Or
    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: {
            type: 'user',
            someConfig: true
        }
    });

    // Can also instance at runtime
    var ctrl = new MyApp.UserController();
    var view = new UserContainer({
        controller: ctrl
    });
<br/><br/>
defaultListenerScope<br/>If `true`, this component will be the default scope (this pointer) for events
specified with string names so that the scope can be dynamically resolved. The
component will automatically become the defaultListenerScope if a
{@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for some sample
usages.

**NOTE**: This value can only be reliably set at construction time. Setting it
after that time may not correctly rewire all of the potentially effected
listeners.
<br/><br/>
defaultToolWeights<br/>The default `weight` for tools in the `header`.
<br/><br/>
disabled<br/>Whether or not this component is disabled
<br/><br/>
encodeHtml<br/>Specify `false` to write HTML directly to the cell. Be aware that doing this
can expose your application to security issues if that content is not known to
be safe. User input can contain malicious content such as `script` tags and
should be scrubbed before directly rendering that HTML.
<br/><br/>
undefined<br/><br/><br/>
flex<br/>The flex of this item *if* this item item is inside a {@link Ext.layout.HBox}
or {@link Ext.layout.VBox} layout.

You can also update the flex of a component dynamically using
the {@link Ext.layout.FlexBox#setItemFlex} method.

When supplied as a string or number this option supports the same syntax
as CSS [flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).
For example:

    flex: '1 2 auto'

sets `flex-grow` property to `0`, `flex-shrink` to `2` and `flex-basis` to
`'auto'`.

The default `flex-shrink` value for box layout items is set to `0` in the
stylesheet, which is different from the browser's default `flex-shrink` value
of `1`.  This accommodates the majority use case for applications since where
non-flexed components are typically not expected to shrink smaller than their
default size.

For convenience when only a single number is supplied it is used as the value
for both `flex-grow` and `flex-shrink`, for example `flex: 3` is the same as
`flex: '3 3'`

An object form is also accepted:

    flex: {
        grow: 1,
        shrink: 2,
        basis: 'auto'
    }

When the object form is supplied `shrink` always defaults to `0` regardless
of the value of `grow`.

Although `'auto'` is the default value for flex-basis, flex-basis defaults to 0%
when flex is supplied as a single numeric or string value (e.g. `flex: 1`). If
this behavior is not desired either explicitly set flex-basis to `'auto'` or use
the object form to set only grow and/or shrink:

    flex: {
        grow: 2
    }
<br/><br/>
floated<br/>A Component may be floated above all other components in the application. This means that
the component is absolutely positioned, and will move to the front and occlude other
sibling floated component if clicked.

A Floated component may have floated descendants. It will bring these decendants to the
front with it when brought to the front of its sibling floated components.

By default, descendant floated components are all positioned using the viewport
coordinate system. To make a floating component a positioning parent for descendants,
and have the ancestors positioned relatively, configure the parent floated component
with `{@link #cfg!relative #cfg-relative}: true`.
<br/><br/>
focusCls<br/>CSS class that will be added to focused
component's {@link #property!focusClsEl #focusClsEl}, and removed when component blurs.
<br/><br/>
format<br/>A format string as used by {@link Ext.Date#method!format Ext.Date#format} to format values for this
column.
<br/><br/>
height<br/>The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
hidden<br/>The hidden state of this cell (propagated from the column's hidden state).
<br/><br/>
hideMode<br/>A String which specifies how this component's DOM element will be hidden. The
accepted values are any of these:

- `'clip'` : Hide using {@link Ext.dom.Element#static-property!CLIP clip}.
- `'display'` : Hide using {@link Ext.dom.Element#static-property!DISPLAY display}.
- `'offsets'` : Hide using positioning {@link Ext.dom.Element#static-property!OFFSETS offsets}.
- `'opacity'` : Hide using {@link Ext.dom.Element#static-property!OPACITY opacity}.
- `'visibility'` : Hide using {@link Ext.dom.Element#static-property!VISIBILITY visibility}.

Hiding using ``display`` results in having no dimensions as well as resetting
scroll positions to 0.

The other modes overcome this but may have different trade-offs in certain
circumstances.
<br/><br/>
id<br/>The **unique id of this component instance.**

It should not be necessary to use this configuration except for singleton objects in
your application. Components created with an id may be accessed globally
using {@link Ext#method!getCmp Ext.getCmp}.

Instead of using assigned ids, use the {@link #cfg!itemId #itemId} config,
and {@link Ext.ComponentQuery} which provides selector-based searching
for Sencha Components analogous to DOM querying. The {@link Ext.Container} class
contains {@link Ext.Container#method!down shortcut methods} to query its descendant Components
by selector.

Note that this id will also be used as the element id for the containing HTML element
that is rendered to the page for this component. This allows you to write id-based CSS
rules to style the specific instance of this component uniquely, and also to select
sub-elements using this component's id as the parent.

**Note**: to avoid complications imposed by a unique id also see `{@link #cfg!itemId #itemId}`.

Defaults to an auto-assigned id.
<br/><br/>
instanceCls<br/>
An extra CSS class or classes to augment the {@link #property!classCls #classCls} on an individual instance
<br/><br/>
itemId<br/>An itemId can be used as an alternative way to get a reference to a component when no
object reference is available. Instead of using an `{@link #cfg!id #id}` with {@link Ext#method!getCmp Ext#getCmp},
use `{@link #cfg!itemId itemId}` with {@link Ext.Container#method!getComponent Ext.Container#getComponent} which will retrieve `{@link #cfg!itemId itemId}`'s or
{@link #cfg!id #id}'s. Since `{@link #cfg!itemId itemId}`'s are an index to the container's internal MixedCollection,
the `{@link #cfg!itemId itemId}` is scoped locally to the container - avoiding potential conflicts with
{@link Ext.ComponentManager} which requires a **unique** `{@link #cfg!id #id}`.

Also see {@link #cfg!id #id}, {@link Ext.Container#method!query Ext.Container#query}, {@link Ext.Container#method!down Ext.Container#down} and
{@link Ext.Container#method!child Ext.Container#child}.
<br/><br/>
keyMap<br/>An object containing handlers for keyboard events. The property names of this
object are the key name and any modifiers. The values of the properties are the
descriptors of how to handle each event.

The handler descriptor can be simply the handler function(either the
literal function or the method name), or it can be an object with these
properties:

 - `handler`: The function or its name to call to handle the event.
 - `scope`: The this pointer context (can be "this" or "controller").
 - `event`: An optional override of the key event to which to listen.

**Important:** Calls to `setKeyMap` do not replace the entire `{@link #cfg!keyMap keyMap}` but
instead update the provided mappings. That is, unless `null` is passed as the
value of the `{@link #cfg!keyMap keyMap}` which will clear the `{@link #cfg!keyMap keyMap}` of all entries.
<br/><br/>
keyMapEnabled<br/>Enables or disables processing keys in the `{@link #cfg!keyMap keyMap}`. This value starts as
`null` and if it is `null` when `{@link #method!initKeyMap initKeyMap}` is called, it will automatically
be set to `true`. Since `{@link #method!initKeyMap initKeyMap}` is called by `{@link Ext.Component}` at the
proper time, this is not something application code normally handles.
<br/><br/>
keyMapTarget<br/>The name of the member that should be used to listen for keydown/keypress events.
This is intended to be controlled at the class level not per instance.
<br/><br/>
listeners<br/>
A config object containing one or more event handlers to be added to this object during
initialization. This should be a valid listeners config object as specified in the
{@link Ext.util.Observable#method!addListener addListener} example for attaching
multiple handlers at once.

**DOM events from Ext JS {@link Ext.Component}**

While _some_ Ext JS Component classes export selected DOM events (e.g. "click",
"mouseover" etc), this is usually only done when extra value can be added. For example
the {@link Ext.view.View DataView}'s **`{@link Ext.view.View#itemclick itemclick}`**
event passing the node clicked on. To access DOM events directly from a child element
of a Component, we need to specify the `element` option to identify the Component
property to add a DOM listener to:

    new Ext.panel.Panel({
        width: 400,
        height: 200,
        dockedItems: [{
            xtype: 'toolbar'
        }],
        listeners: {
            click: {
                element: 'el', //bind to the underlying el property on the panel
                fn: function(){ console.log('click el'); }
            },
            dblclick: {
                element: 'body', //bind to the underlying body property on the panel
                fn: function(){ console.log('dblclick body'); }
            }
        }
    });
<br/><br/>
margin<br/>The margin to use on this Component. Can be specified as a number (in which
case all edges get the same margin) or a CSS string like '5 10 10 10'
<br/><br/>
name<br/>Name for the widget to be used with {@link Ext.Container#method!lookupName Ext.Container#lookupName}
et al.
<br/><br/>
nameable<br/>Set to `true` for this component's `name` property to be tracked by its containing
`nameHolder`.
<br/><br/>
plugins<br/>This config describes one or more plugin config objects used to create plugin
instances for this component.

Plugins are a way to bundle and reuse custom functionality. Plugins should extend
`{@link Ext.plugin.Abstract}` but technically the only requirement for a valid plugin
is that it contain an `init` method that accepts a reference to its owner. Once
a plugin is created, the owner will call the `init` method, passing a reference
to itself. Each plugin can then call methods or respond to events on its owner
as needed to provide its functionality.

This config's value can take several different forms.

The value can be a single string with the plugin's {@link Ext.enums.Plugin alias}:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: 'listpaging'
     });

In the above examples, the string "listpaging" is the type alias for
`{@link Ext.dataview.plugin.ListPaging}`. The full alias includes the "plugin." prefix
(i.e., 'plugin.listpaging').

The preferred form for multiple plugins or to configure plugins is the
keyed-object form (new in version 6.5):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: {
             pullrefresh: true,
             listpaging: {
                 autoPaging: true,
                 weight: 10
             }
         }
     });

The object keys are the `id`'s as well as the default type alias. This form
allows the value of the `{@link #cfg!plugins plugins}` to be merged from base class to derived class
and finally with the instance configuration. This allows classes to define a
set of plugins that derived classes or instantiators can further configure or
disable. This merge behavior is a feature of the
{@link Ext.Class#cfg!config}.

The `{@link #cfg!plugins plugins}` config can also be an array of plugin aliases (arrays are not
merged so this form does not respect plugins defined by the class author):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

An array can also contain elements that are config objects with a `type`
property holding the type alias:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: ['pullrefresh', {
             type: 'listpaging',
             autoPaging: true
         }]
     });
<br/><br/>
publishes<br/>One or more names of config properties that this component should publish
to its ViewModel. Generally speaking, only properties defined in a class config
block (including ancestor config blocks and mixins) are eligible for publishing
to the viewModel. Some components override this and publish their most useful
configs by default.

**Note:** We'll discuss publishing properties **not** found in the config block below.

Values determined to be invalid by component (often form fields and model validations)
will not be published to the ViewModel.

This config uses the `{@link #cfg!reference #cfg-reference}` to determine the name of the data
object to place in the `ViewModel`. If `{@link #cfg!reference reference}` is not set then this config
is ignored.

By using this config and `{@link #cfg!reference #cfg-reference}` you can bind configs between
components. For example:

     ...
         items: [{
             xtype: 'textfield',
             reference: 'somefield',  // component's name in the ViewModel
             publishes: 'value' // value is not published by default
         },{
             ...
         },{
             xtype: 'displayfield',
             bind: 'You have entered "{somefield.value}"'
         }]
     ...

Classes must provide this config as an Object:

     Ext.define('App.foo.Bar', {
         publishes: {
             foo: true,
             bar: true
         }
     });

This is required for the config system to properly merge values from derived
classes.

For instances this value can be specified as a value as show above or an array
or object as follows:

     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: [
             'value',
             'rawValue',
             'dirty'
         ]
     }

     // This achieves the same result as the above array form.
     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: {
             value: true,
             rawValue: true,
             dirty: true
         }
     }

In some cases, users may want to publish a property to the viewModel that is not found
in a class  config block. In these situations, you may utilize {@link #method!publishState #publishState}
if the property has a  setter method. Let's use
{@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:

      setFieldLabel: function(fieldLabel) {
          this.callParent(arguments);
          this.publishState('fieldLabel', fieldLabel);
      }

With the above chunk of code, fieldLabel may now be published to the viewModel.
<br/><br/>
rawValue<br/>The text value of the cell. This value will be written to the cell differently
based on the {@link #cfg!encodeHtml #encodeHtml} config. This config is automatically set as a
result of setting the {@link #cfg!value #value} config and is rarely set directly. This is
a separate config to avoid writting the same formatted result to the DOM.
<br/><br/>
record<br/>The currently associated record.
<br/><br/>
reference<br/>Specifies a name for this component inside its component hierarchy. This name
must be unique within its {@link Ext.Container#cfg!referenceHolder view}
or its {@link Ext.app.ViewController}. See the documentation in
{@link Ext.Container Ext.container.Container} for more information about references.

**Note**: Valid identifiers start with a letter or underscore and are followed
by zero or more additional letters, underscores or digits. References are case
sensitive.
<br/><br/>
relative<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure this as `true` if you require descendant floated components to be positioned
relative to this component's coordinate space, not the viewport's coordinate space.

*Note:* The coordinate space is this Component's encapsulating element's area. Not that
of the inner element in which static child items are rendered by the layout.
<br/><br/>
renderTo<br/>Optional element to render this Component to.
Not required if this component is an {@link Ext.Container#cfg!items item} of a Container
of a Container.
<br/><br/>
ripple<br/>Set to truthy, Color or Object value for the ripple.
<br/><br/>
selectable<br/>Set to `false` to disable selection of the record when tapping on this cell.
<br/><br/>
session<br/>If provided this creates a new `Session` instance for this component. If this
is a `Container`, this will then be inherited by all child components.

To create a new session you can specify `true`:

     Ext.create({
         xtype: 'viewport',
         session: true,

         items: [{
             ...
         }]
     });

Alternatively, a config object can be provided:

     Ext.create({
         xtype: 'viewport',
         session: {
             ...
         },

         items: [{
             ...
         }]
     });
<br/><br/>
shadow<br/>Configure as `true` for the component to have a drop shadow. 'false' will suppress any
default shadow. By default the theme will determine the presence of a shadow.
<br/><br/>
shareableName<br/>Set to `true` to allow this component's `name` to be shared by other items in the
same `nameHolder`. Such items will be returned in an array from `lookupName`.
<br/><br/>
shim<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure as `true` for the component to use an `&lt;iframe&gt;` as an underlay to ensure
certain non-standard browser plugins are occluded by this component.
<br/><br/>
style<br/>Additional CSS styles that will be rendered into an inline style attribute when
the widget is rendered.

You can pass either a string syntax:

    style: 'background:red'

Or by using an object:

    style: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    style: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
<br/><br/>
toFrontOnShow<br/>True to automatically call {@link #method!toFront #toFront} when a {@link #cfg!floated #cfg-floated} Component is
shown.
<br/><br/>
toolDefaults<br/>The properties of this object are shallow copied (via {@link Ext#method!applyIf applyIf()}
as opposed to {@link Ext#method!merge Ext.merge()} to each tool declared in the `{@link #cfg!tools tools}`
config.
<br/><br/>
tools<br/>An array of {@link Ext.Tool} configs or an object keyed by `itemId`.
<br/><br/>
touchAction<br/>
Emulates the behavior of the CSS
[touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
property in a cross-browser compatible manner.

Keys in this object are touch action names, and values are `false` to disable
a touch action or `true` to enable it.  Accepted keys are:

- `panX`
- `panY`
- `pinchZoom`
- `doubleTapZoom`

All touch actions are enabled (`true`) by default, so it is usually only necessary
to specify which touch actions to disable.  For example, the following disables
only horizontal scrolling and pinch-to-zoom on the component's main element:

    touchAction: {
        panX: false,
        pinchZoom: false
    }

Touch actions can be specified on reference elements using the reference element
name, for example:

    // disables horizontal scrolling on the main element, and double-tap-zoom
    // on the child element named "body"
    touchAction: {
        panY: false
        body: {
            doubleTapZoom: false
        }
    }

The primary motivation for setting the touch-action of an element is to prevent
the browser's default handling of a gesture such as pinch-to-zoom, or
drag-to-scroll, so that the application can implement its own handling of that
gesture on the element.  Suppose, for example, a component has a custom drag
handler on its element and wishes to prevent horizontal scrolling of its container
while it is being dragged:

    Ext.create('Ext.Widget', {
        touchAction: {
            panX: false
        },
        listeners: {
            drag: function(e) {
                // implement drag logic
            }
        }
    });
<br/><br/>
translatable<br/><br/><br/>
twoWayBindable<br/>This object holds a map of `config` properties that will update their binding
as they are modified. For example, `value` is a key added by form fields. The
form of this config is the same as `{@link #cfg!publishes}`.

This config is defined so that updaters are not created and added for all
bound properties since most cannot be modified by the end-user and hence are
not appropriate for two-way binding.
<br/><br/>
ui<br/>The ui or uis to be used on this Component

When a ui is configured, CSS class names are added to the {@link #property!element #element}, created
by appending the ui name(s) to each {@link #property!classCls #classCls} and/or {@link #property!baseCls #baseCls}.
<br/><br/>
userCls<br/>One or more CSS classes to add to the component's primary element. This config
is intended solely for use by the component instantiator (the "user"), not by
derived classes.

For example:

     items: [{
         xtype: 'button',
         userCls: 'my-button'
     ...
     }]
<br/><br/>
value<br/>The value of the {@link Ext.grid.column.Column#cfg!dataIndex dataIndex} field of
the associated record. Application code should not need to set this value.
<br/><br/>
viewModel<br/>The `ViewModel` is a data provider for this component and its children. The
data contained in the `ViewModel` is typically used by adding `{@link #cfg!bind bind}` configs
to the components that want present or edit this data.

When set, the `ViewModel` is created and links to any inherited `{@link #cfg!viewModel viewModel}`
instance from an ancestor container as the "parent". The `ViewModel` hierarchy,
once established, only supports creation or destruction of children. The
parent of a `ViewModel` cannot be changed on the fly.

If this is a root-level `ViewModel`, the data model connection is made to this
component's associated `{@link Ext.data.Session}`. This is
determined by calling `getInheritedSession`.
<br/><br/>
width<br/>The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
x<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
<br/><br/>
y<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
<br/><br/>
zeroValue<br/>
A replacement value for 0.

If the cell value is 0 and you want to display it or hide it then you can define
a not null value here.

Set it as an empty string if you want to hide cells that have 0s.
<br/><br/>

            </div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
            <div class="flex-container">
                methoda
            </div>
        </z-tabpanel>

        <z-tabpanel tabname="events">
            <div class="flex-container">
                onBeforedisabledchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeheightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforehiddenchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforetofront = ( {detail: { sender }} ) => {}<br/>
onBeforewidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBlur = ( {detail: { sender, event }} ) => {}<br/>
onDisabledchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onFocus = ( {detail: { sender, event }} ) => {}<br/>
onFocusenter = ( {detail: { sender, event }} ) => {}<br/>
onFocusleave = ( {detail: { sender, event }} ) => {}<br/>
onHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onHiddenchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onTofront = ( {detail: { sender }} ) => {}<br/>
onWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>

            </div>
        </z-tabpanel>

        <z-tabpanel tabname="React">
            <div class="flex-container">

            </div>
        </z-tabpanel>


        <z-tabpanel tabname="Web Components">
            <div class="flex-container">

            </div>
        </z-tabpanel>


    </z-tabs>



    </section>






</div>


</body>
</html>