<!DOCTYPE HTML>
<html>
<head>
<style>

body{
  margin: 0;
  color: #fff;
}
.wrapper{
  min-height: 100vh;
  background: #ccc;
  display: flex;
  flex-direction: column;
}
.content {
  flex: 1;
  background: #999;
  display: flex;
  color: #000;
}


.heading {
    xbackground: blue;
    xpadding: 10px;
    font-size: 24px;
}

.flex-container {
  display: flex;
  flex-direction: row;
  justify-content: center;
  flex-wrap: nowrap;
  align-items: flex-start;
  xbackground-color: DodgerBlue;
}

.flex-container > div {
  background-color: white;
  margin: 10px;
}

.thelist {
    flex-shrink: 0;
}

.thetext {
    flex-grow: 8;height: 200px;padding: 10px;
}

.theframe {
    flex-grow: 8;height: 900px;padding: 0;
}

select{
  background:transparent;
   width: 170px;
   padding: 2px;
   font-family:Arial, Helvetica, sans-serif;
   font-size:11px;
   font-weight:600;
   color:#fff;
   line-height: 1;
   border: 0;
   border-radius: 0;
   height: 22px;
  -webkit-appearance: none;

  }

.select-div{
	width: 170px;
	height: 22px;
	overflow: hidden;
	background: url(arrowhead.png) no-repeat right #363636;
	border-top:#575757 1px solid;
	-webkit-border-radius: 4px 4px 4px 4px;
	 -moz-border-radius: 4px 4px 4px 4px;
		  border-radius: 4px 4px 4px 4px;
	-webkit-box-shadow: inset 0 2px 4px rgba(107, 105, 105, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
	 -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
		  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
		  -moz-box-shadow:    0px 8px 3px -9px #000000;
		  -webkit-box-shadow: 0px 8px 3px -9px #000000;
		  box-shadow:         0px 8px 3px -9px #000000;
}

select > option {
  background: pink;
}


.frame {
    overflow-y: auto;
    border: 1px solid black;
    height: 30em;
    width: 20em;
    line-height: 1em;
}

.frame::-webkit-scrollbar {
    -webkit-appearance: none;
}

.frame::-webkit-scrollbar:vertical {
    width: 11px;
}

.frame::-webkit-scrollbar:horizontal {
    height: 11px;
}

.frame::-webkit-scrollbar-thumb {
    border-radius: 8px;
    border: 2px solid white; /* should match background, can't be transparent */
    background-color: rgba(0, 0, 0, .5);
}




.code {
    background: gainsboro;
    padding: 10px;
}

.grid-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: flex-start;
}

.grid-item {
  height: 30px;
  flex-basis: 20%;
  -ms-flex: auto;
  width: 100px;
  position: relative;
  padding: 10px;
  box-sizing: border-box;
}
.grid-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: flex-start;
}

.grid-item {
  height: 30px;
  flex-basis: 20%;
  -ms-flex: auto;
  width: 100px;
  position: relative;
  padding: 10px;
  box-sizing: border-box;
}

/* Tooltip container */
.tooltip {
  position: relative;
  display: inline-block;
  xborder-bottom: 1px dotted black; /* If you want dots under the hoverable text */
}

/* Tooltip text */
.tooltip .tooltiptext {
  visibility: hidden;
  width: 400px;
  background-color: #555;
  color: #fff;
  text-align: left;
  padding: 5px 5px 5px 5px;
  border-radius: 6px;

  /* Position the tooltip text */
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  margin-left: -60px;

  /* Fade in tooltip */
  opacity: 0;
  transition: opacity 0.3s;
}

/* Tooltip arrow */
.tooltip .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 10%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #555 transparent transparent transparent;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
</style>
<script src="z-tabs.js"></script>

</head>
<body>



<div class="wrapper">

    <section class="content">

    <z-tabs>

        <z-tabpanel tabname="overview">
            <div class="flex-container">





            </div>
        </z-tabpanel>




        <z-tabpanel tabname="usage">
            <div class="flex-container">




            </div>
        </z-tabpanel>



        <z-tabpanel tabname="properties">
            <div class="flex-container">
               activeChildTabIndex<br/>DOM tabIndex attribute to set on the
active Focusable child of this container when using the "Roaming tabindex"
technique.
<br/><br/>
activeItem<br/>The item from the {@link #cfg!items #cfg-items}
collection that will be active first. This is usually only meaningful in a
{@link Ext.layout.Card}, where only one item can be active at a time. If
passed a string, it will be assumed to be a {@link Ext.ComponentQuery} selector. A number
will reference an index or a {@link Ext.Component} instance may be passed as
well. An object config will be created as a new component.
<br/><br/>
align<br/>Sets the alignment of the header and rendered columns.
Possible values are: `'left'`, `'center'`, and `'right'`.
<br/><br/>
alignSelf<br/>Specifies the self alignment of this widget in a box layout
<br/><br/>
allowFocusingDisabledChildren<br/>Set this to `true`
to enable focusing disabled child items via keyboard.
<br/><br/>
alwaysOnTop<br/>A flag indicating that this component should
be above its floated siblings.

This may be a positive number to prioritize the ordering of multiple visible always on
top components.

This may be set to a *negative* number to prioritize a component to the *bottom* of the
z-index stack.
<br/><br/>
ariaAttributes<br/>An object containing ARIA attributes to be set
on this Component's ARIA element. Use this to set the attributes that cannot be
determined by the Component's state, such as `aria-live`, `aria-flowto`, etc.

**Note** that this config is only meaningful at the Component rendering time,
and setting it after that will do nothing.
<br/><br/>
ariaDescribedBy<br/>DOM selector for a child element that is to be used
as description for this Component, set in `aria-describedby` attribute.
The selector works the same way as {@link #cfg!ariaLabelledBy #ariaLabelledBy}.
<br/><br/>
ariaLabel<br/>ARIA label for this Component. It is best to use
{@link #cfg!ariaLabelledBy #ariaLabelledBy} option instead, because screen readers prefer
`aria-labelledby` attribute to `aria-label`. {@link #cfg!ariaLabel #ariaLabel} and
{@link #cfg!ariaLabelledBy #ariaLabelledBy} config options are mutually exclusive.
<br/><br/>
ariaLabelledBy<br/>DOM selector for a child element that is to be used
as label for this Component, set in `aria-labelledby` attribute.
If the selector is by `{@link #cfg!id #id}`, the label element can be any existing element,
not necessarily a child of the main Component element.

{@link #cfg!ariaLabelledBy #ariaLabelledBy} and {@link #cfg!ariaLabel #ariaLabel} config options are
mutually exclusive, and `{@link #cfg!ariaLabelledBy ariaLabelledBy}` has the higher precedence.
<br/><br/>
autoDestroy<br/>If `true`, child items will be destroyed as soon as they are
{@link #method!remove removed} from this container.
<br/><br/>
autoSize<br/>May be set to `false` for improved layout performance if auto-sizing is not required.

Some versions of Safari, both desktop and mobile, have very slow performance
if the application has deeply nested containers due to the following WebKit
bug: https://bugs.webkit.org/show_bug.cgi?id=150445

Applications that experience performance issues in the affected versions of
Safari may need to turn off autoSizing globally for all `{@link Ext.Container}` instances
by placing the following override in the application's "overrides" directory:

    Ext.define('MyApp.overrides.Container', {
        override: 'Ext.Container',
        config: {
            autoSize: false
        }
    });

Once auto-sizing support has turned off by default, it can be selectively
turned back on only on those container instances that explicitly need auto-sizing
behavior by setting `{@link #cfg!autoSize autoSize}` to `true`.

This option can also be used to allow items to be sized in percentage
units as a workaround for the following browser bug:
https://bugs.webkit.org/show_bug.cgi?id=137730

To illustrate, the following example should render a 200px by 200px green box
(the container) with a yellow box inside of it (the child item).  The child
item's height and width are both set to `'50%'` so the child should render
exactly 100px by 100px in size.

    @example
    Ext.create({
        xtype: 'container',
        renderTo: Ext.getBody(),
        height: 200,
        width: 200,
        style: 'background: green',
        items: [{
            xtype: 'component',
            style: 'background: yellow',
            height: '50%',
            width: '50%'
        }]
    });

All browsers except for Safari render the previous example correctly, but
Safari does not assign a height to the component.  To make percentage-sized
items work in Safari, simply set `{@link #cfg!autoSize autoSize}` to `false` on the container.

Since the underlying implementation works by absolutely positioning the container's
body element, this option can only be used when the container is not
"shrink wrapping" the content in either direction.  When `{@link #cfg!autoSize autoSize}` is
set to `false`, shrink wrapped dimension(s) will collapse to 0.
<br/><br/>
axisLock<br/>If `true`, then, when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo} fallback on
constraint violation only takes place along the major align axis.

That is, if alignment `"l-r"` is being used, and `axisLock: true` is used,
then if constraints fail, only fallback to `"r-l"` is considered.
<br/><br/>
bind<br/>Setting this config option adds or removes data bindings for other configs.
For example, to bind the `title` config:

     var panel = Ext.create({
         xtype: 'panel',
         bind: {
             title: 'Hello {user.name}'
         }
     });

To dynamically add bindings:

     panel.setBind({
         title: 'Greetings {user.name}!'
     });

To remove bindings:

     panel.setBind({
         title: null
     });

The bind expressions are presented to `{@link Ext.app.ViewModel#method!bind Ext.app.ViewModel#bind}`. The
`ViewModel` instance is determined by `{@link #method!lookupViewModel lookupViewModel}`.

**Note:** If  bind is passed as a string, it will use the
{@link Ext.Component#property!defaultBindProperty Ext.Component#property-defaultBindProperty} for the binding.
<br/><br/>
bodyCls<br/>The CSS class to add to this container's body element.
<br/><br/>
border<br/>Enables or disables bordering on this component.
The following values are accepted:

- `null` or `true (default): Do nothing and allow the border to be specified
by the theme.
- `false`: suppress the default border provided by the theme.

Please note that enabling bordering via this config will not add a `border-color`
or `border-style` CSS property to the component; you provide the `border-color`
and `border-style` via CSS rule or {@link #cfg!style #style} configuration
(if not already provide by the theme).

## Using {@link #cfg!style #style}:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        style: 'border: 1px solid blue;'
        // ...
    });

## Using CSS:

    Ext.Viewport.add({
        centered: true,
        width: 100,
        height: 100,

        cls: 'my-component'
        // ...
    });

And your CSS file:

    .my-component {
        border: 1px solid red;
    }
<br/><br/>
bottom<br/>The absolute bottom position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
<br/><br/>
cardSwitchAnimation<br/>Animation to be used during transitions of cards.
<br/><br/>
cell<br/>The config object used to create {@link Ext.grid.cell.Base} for this column.
By default, cells use the {@link Ext.grid.cell.Cell} `{@link #cfg!xtype xtype}`. To create
a different type of cell, simply provide this config and the desired `{@link #cfg!xtype xtype}`.
<br/><br/>
centered<br/>Configure this as `true` to have this Component centered within its Container.
Setting this value to `true` will make this Component become 'positioned', which means
it will no longer participate in the layout of the Container that it resides in.
<br/><br/>
cls<br/>The CSS class to add to this widget's element, in
addition to the {@link #property!baseCls #baseCls}. In many cases, this property will be specified
by the derived widget class. See {@link #cfg!userCls #userCls} for adding additional CSS
classes to widget instances (such as items in a {@link Ext.Container}).
<br/><br/>
columns<br/>The sub columns within this column/header container.
<br/><br/>
computedWidth<br/>The computed width for this column, may come from either
{@link #cfg!width #width} or {@link #cfg!flex #flex}.
<br/><br/>
constrainAlign<br/>A specification of the constraint to apply when {@link #method!showBy #showBy} or {@link #method!alignTo #alignTo}
is called to align a {@link #cfg!floated #floated} or positioned component.

Defaults to the parent container for *positioned* components (components
which have their {@link #cfg!top}, {@link #cfg!right}, {@link #cfg!bottom} or
{@link #cfg!left} set to move them out of their container's layout flow).

Defaults to the viewport for {@link #cfg!floated #floated} components.

May be a {@link Ext.ComponentQuery} selector to find an ancestor
component to constrain within.

May be `false` to specify that constraining is not applied.

You may also specify an element, or a {@link Ext.util.Region}
<br/><br/>
contentEl<br/>The configured element will automatically be added as the content of this
component. When you pass a string, we expect it to be an element id. If the
content element is hidden, we will automatically show it.
<br/><br/>
control<br/>Enables you to easily control Components inside this Container by
listening to their events and taking some action. For example, if we had a container with
a nested Disable button, and we wanted to hide the Container when the Disable button is
tapped, we could do this:

    @example
    Ext.create({
        xtype: 'container',
        control: {
           'button[text=Disable]': {
               tap: 'hideMe'
           }
        },

        hideMe: function() {
            this.hide();
        }
    });

We used a {@link Ext.ComponentQuery} selector to listen to the {@link Ext.Button#event!tap tap}
event on any {@link Ext.Button} anywhere inside the Container that has the
{@link Ext.Button#cfg!text text} 'Disable'. Whenever a Component matching that selector
fires the `tap` event our `hideMe` function is called. `hideMe` is called with scope:
`this` (e.g. `this` is the Container instance).
<br/><br/>
controller<br/>A string alias, a configuration object or an instance of a `ViewController` for
this container. Sample usage:

    Ext.define('MyApp.UserController', {
        alias: 'controller.user'
    });

    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: 'user'
    });
    // Or
    Ext.define('UserContainer', {
        extend: 'Ext.container.container',
        controller: {
            type: 'user',
            someConfig: true
        }
    });

    // Can also instance at runtime
    var ctrl = new MyApp.UserController();
    var view = new UserContainer({
        controller: ctrl
    });
<br/><br/>
data<br/>The initial set of data to apply to the `{@link #cfg!tpl #tpl}` to
update the content area of the Component.

**Note:** Data will be appended to any existing data.
<br/><br/>
dataIndex<br/>The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Model}
definition from which to draw the column's value.
<br/><br/>
defaultColumnUI<br/>A default {@link #cfg!ui ui} to use for {@link Ext.grid.column.Column} in
this header.
<br/><br/>
defaultEditor<br/>An optional config object used to create a default editor for values in this
column when no {@link #cfg!editor #editor} is specified. This config is typically defined
by derived column classes such as {@link Ext.grid.column.Date} to
tune the default editor.

This value is augmented by the {@link #cfg!editorDefaults}
config.
<br/><br/>
defaultFocus<br/>
Specifies a child Component to receive focus when this Container's {@link #method!focus #method-focus}
method is called. Should be a valid {@link Ext.ComponentQuery} selector.
<br/><br/>
defaultListenerScope<br/>If `true`, this component will be the default scope (this pointer) for events
specified with string names so that the scope can be dynamically resolved. The
component will automatically become the defaultListenerScope if a
{@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for some sample
usages.

**NOTE**: This value can only be reliably set at construction time. Setting it
after that time may not correctly rewire all of the potentially effected
listeners.
<br/><br/>
defaults<br/>A set of default configurations to apply to all child Components
in this Container. It's often useful to specify defaults when creating more than one
items with similar configurations. For example here we can specify that each child is a
panel and avoid repeating the xtype declaration for each one:

    @example
    Ext.create({
        xtype: 'container',
        defaults: {
            xtype: 'panel'
        },
        items: [
            {
                html: 'Panel 1'
            },
            {
                html: 'Panel 2'
            }
        ]
    });
<br/><br/>
defaultToolWeights<br/>The default `weight` for tools in the `header`.
<br/><br/>
defaultType<br/>The default {@link Ext.Component} of child Components to create in this Container
when a child item is specified as a raw configuration object, rather than as an
instantiated Component.
<br/><br/>
defaultWidth<br/>A width to apply if the {@link #cfg!flex #flex} or {@link #cfg!width #width} configurations have not
been specified.
<br/><br/>
depends<br/>Set this config to the field names that effect this column's rendering. This is
important for best performance when using a `{@link #cfg!renderer renderer}`, a `{@link #cfg!summaryRenderer summaryRenderer}` or
a `{@link #cfg!tpl tpl}` to render the cell's content. This is because such mechanisms can use
any field and as such must be refreshed on *any* field change. When this config
is provided, only changes to these fields (or the `{@link #cfg!dataIndex dataIndex}`) will cause a
refresh.

When not using these mechanisms, only changes to the `{@link #cfg!dataIndex dataIndex}` will cause the
cell content to be refreshed.
<br/><br/>
disabled<br/>Whether or not this component is disabled
<br/><br/>
displayed<br/>Set to `true` to call `show` and `false` to call `hide`. Unlike the `{@link #cfg!hidden hidden}`
config, changing this config will potentially involve animations to show or
hide the component.
<br/><br/>
docked<br/>The dock position of this component in its container. Can be `{@link #cfg!left left}`, `{@link #cfg!top top}`, `{@link #cfg!right right}` or
`{@link #cfg!bottom bottom}`.

__Notes__

You must use a HTML5 doctype for {@link #cfg!docked #docked} `{@link #cfg!bottom bottom}` to work. To do this, simply
add the following code to the HTML file:

    &lt;!doctype html&gt;

So your index.html file should look a little like this:

    &lt;!doctype html&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;MY application title&lt;/title&gt;
            ...
<br/><br/>
draggable<br/>Set to `true` to allow this component to be dragged. This can also be the config
object for the `{@link Ext.drag.Source}` that will manage the drag.
<br/><br/>
editable<br/>Set this to true to make this column editable.
Only applicable if the grid is using an {@link Ext.grid.plugin.Editable} plugin.
<br/><br/>
editor<br/>The `{@link #cfg!xtype xtype}` or config object for a {@link Ext.field.Field} to use for
editing. This config is used by the {@link Ext.grid.plugin.Editable}
plugin.

If this config is not set, and {@link #cfg!editable #editable} is set to true, the
{@link #cfg!defaultEditor #defaultEditor} is used.
<br/><br/>
editorDefaults<br/>This object holds default config objects for creating the column's `{@link #cfg!editor editor}`.
The keys of this object are {@link Ext.data.field.Field#cfg!type field type}
values (such as `'date'` or `'int'`). These keys can also be a comma-separated
list of such type names.

These defaults are applied when producing an `{@link #cfg!editor editor}` based on the field of
{@link #cfg!store store's} {@link Ext.data.Store#cfg!model} identified
by the {@link #cfg!dataIndex}.

See {@link #method!ensureEditor ensureEditor}.
<br/><br/>
undefined<br/><br/><br/>
undefined<br/><br/><br/>
undefined<br/><br/><br/>
exportRenderer<br/>
During data export via the {@link Ext.grid.plugin.Exporter} plugin the data for
this column could be formatted in multiple ways:

- using the `exportStyle.format`
- using the `{@link #cfg!formatter formatter}` if no `{@link #cfg!exportStyle exportStyle}` is defined
- using the `{@link #cfg!exportRenderer exportRenderer}`

If you want to use the `{@link #cfg!renderer renderer}` defined on this column then set `{@link #cfg!exportRenderer exportRenderer}`
to `true`. Beware that this should only happen if the `{@link #cfg!renderer renderer}` deals only with
data on the record or value and it does NOT style the cell or returns an html
string.

     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         text: 'Price',
         renderer: function(value, record, dataIndex, cell, column) {
             return Ext.util.Format.currency(value);
         },
         exportRenderer: true
     }

If you don't want to use the `{@link #cfg!renderer renderer}` during export but you still want to format
the value in a special way then you can provide a function to `{@link #cfg!exportRenderer exportRenderer}` or
a string (which is a function name on the ViewController).
The provided function has the same signature as the renderer.

     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         text: 'Price',
         exportRenderer: function(value, record, dataIndex, cell, column) {
             return Ext.util.Format.currency(value);
         }
     }


     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         text: 'Price',
         exportRenderer: 'exportAsCurrency' // this is a function on the ViewController
     }


If `exportStyle.format`, `{@link #cfg!formatter formatter}` and `{@link #cfg!exportRenderer exportRenderer}` are all defined on the
column then the `{@link #cfg!exportStyle exportStyle}` wins and will be used to format the data for this
column.
<br/><br/>
exportStyle<br/>
A style definition that is used during data export via the
{@link Ext.grid.plugin.Exporter}. This style will be applied to
the columns generated in the exported file.

You could define it as a single object that will be used by all exporters:

     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         exportStyle: {
             format: 'Currency',
             alignment: {
                 horizontal: 'Right'
             },
             font: {
                 italic: true
             }
         }
     }

You could also define it as an array of objects, each object having a `type`
that specifies by which exporter will be used:

     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         exportStyle: [{
             type: 'html', // used by the `{@link #cfg!html html}` exporter
             format: 'Currency',
             alignment: {
                 horizontal: 'Right'
             },
             font: {
                 italic: true
             }
         },{
             type: 'csv', // used by the `csv` exporter
             format: 'General'
         }]
     }

Or you can define it as an array of objects that has:

- one object with no `type` key that is considered the style to use by all exporters
- objects with the `type` key defined that are exceptions of the above rule

     {
         xtype: 'numbercolumn',
         dataIndex: 'price',
         exportStyle: [{
             // no type defined means this is the default
             format: 'Currency',
             alignment: {
                 horizontal: 'Right'
             },
             font: {
                 italic: true
             }
         },{
             type: 'csv', // only the CSV exporter has a special style
             format: 'General'
         }]
     }
<br/><br/>
exportSummaryRenderer<br/>
This config is similar to {@link #cfg!exportRenderer #exportRenderer} but is applied to summary
records.
<br/><br/>
filter<br/><br/><br/>
flex<br/>The flex of this item *if* this item item is inside a {@link Ext.layout.HBox}
or {@link Ext.layout.VBox} layout.

You can also update the flex of a component dynamically using
the {@link Ext.layout.FlexBox#setItemFlex} method.

When supplied as a string or number this option supports the same syntax
as CSS [flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex).
For example:

    flex: '1 2 auto'

sets `flex-grow` property to `0`, `flex-shrink` to `2` and `flex-basis` to
`'auto'`.

The default `flex-shrink` value for box layout items is set to `0` in the
stylesheet, which is different from the browser's default `flex-shrink` value
of `1`.  This accommodates the majority use case for applications since where
non-flexed components are typically not expected to shrink smaller than their
default size.

For convenience when only a single number is supplied it is used as the value
for both `flex-grow` and `flex-shrink`, for example `flex: 3` is the same as
`flex: '3 3'`

An object form is also accepted:

    flex: {
        grow: 1,
        shrink: 2,
        basis: 'auto'
    }

When the object form is supplied `shrink` always defaults to `0` regardless
of the value of `grow`.

Although `'auto'` is the default value for flex-basis, flex-basis defaults to 0%
when flex is supplied as a single numeric or string value (e.g. `flex: 1`). If
this behavior is not desired either explicitly set flex-basis to `'auto'` or use
the object form to set only grow and/or shrink:

    flex: {
        grow: 2
    }
<br/><br/>
floated<br/>A Component may be floated above all other components in the application. This means that
the component is absolutely positioned, and will move to the front and occlude other
sibling floated component if clicked.

A Floated component may have floated descendants. It will bring these decendants to the
front with it when brought to the front of its sibling floated components.

By default, descendant floated components are all positioned using the viewport
coordinate system. To make a floating component a positioning parent for descendants,
and have the ancestors positioned relatively, configure the parent floated component
with `{@link #cfg!relative #cfg-relative}: true`.
<br/><br/>
focusableContainer<br/>Enable or disable navigation
with arrow keys for this FocusableContainer. This option may be useful
with nested FocusableContainers, when only the root container should
handle keyboard events.
<br/><br/>
focusCls<br/>CSS class that will be added to focused
component's {@link #property!focusClsEl #focusClsEl}, and removed when component blurs.
<br/><br/>
format<br/>A format string as used by {@link Ext.util.Format#method!number Ext.util.Format#number} to format values
for this column.
<br/><br/>
formatter<br/>This config accepts a format specification as would be used in a `{@link Ext.Template}`
formatted token. For example `'round(2)'` to round numbers to 2 decimal places
or `'date("Y-m-d")'` to format a Date.

In previous releases the `{@link #cfg!renderer renderer}` config had limited abilities to use one
of the `{@link Ext.util.Format}` methods but `{@link #cfg!formatter formatter}` now replaces that usage and
can also handle formatting parameters.

When the value begins with `"this."` (for example, `"this.foo(2)"`), the
implied scope on which "foo" is found is the `{@link #cfg!scope scope}` config for the column.

If the `{@link #cfg!scope scope}` is not given, or implied using a prefix of `"this"`, then either the
{@link #method!getController} or the closest ancestor component
configured as {@link #cfg!defaultListenerScope #defaultListenerScope} is assumed to be the object with the
method.
<br/><br/>
fullscreen<br/>Force the component to take up 100% width and height available, by adding it
to {@link Ext.Viewport}.
<br/><br/>
groupable<br/>If the grid is {@link Ext.grid.Grid#cfg!grouped grouped}, the menu for this column
will offer to "Group by this column" if this is set to `true`.

If using the {@link Ext.grid.plugin.ViewOptions} plugin, this option
may be used to disable the option to group by this column.
<br/><br/>
grouper<br/>A grouper config object to apply when the standard grouping user interface is
is invoked. This option is, for example, available in the column's header
menu.

Note that a grouper may also be specified as a function which accepts two
records to compare.

A `{@link Ext.app.ViewController}` method can be used like so:

     grouper: 'groupMethodName'

This is different then a `{@link #cfg!sorter sorter}` in that the `{@link #cfg!grouper grouper}` method is used to
set the {@link Ext.util.Grouper#cfg!groupFn}. This string returned
by this method is used to determine group membership. To specify both the
`grpoupFn` and the `sorterFn`:

     grouper: {
         groupFn: 'groupMethodName'
         sorterFn: 'sorterMethodName
     }
<br/><br/>
groupHeaderTpl<br/>This config allows a column to replace the default template supplied by the
grid's {@link Ext.grid.RowHeader#cfg!tpl groupHeader.tpl}.
<br/><br/>
height<br/>The height of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
hidden<br/>Whether or not this Component is hidden (its CSS `display` property is set to `none`).

Defaults to `true` for {@link #cfg!floated #floated} Components.
<br/><br/>
hideable<br/>False to prevent the user from hiding this column.
<br/><br/>
hideAnimation<br/>Animation effect to apply when the Component is being hidden.  Typically you want to use
an outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check
the {@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
<br/><br/>
hideMode<br/>A String which specifies how this component's DOM element will be hidden. The
accepted values are any of these:

- `'clip'` : Hide using {@link Ext.dom.Element#static-property!CLIP clip}.
- `'display'` : Hide using {@link Ext.dom.Element#static-property!DISPLAY display}.
- `'offsets'` : Hide using positioning {@link Ext.dom.Element#static-property!OFFSETS offsets}.
- `'opacity'` : Hide using {@link Ext.dom.Element#static-property!OPACITY opacity}.
- `'visibility'` : Hide using {@link Ext.dom.Element#static-property!VISIBILITY visibility}.

Hiding using ``display`` results in having no dimensions as well as resetting
scroll positions to 0.

The other modes overcome this but may have different trade-offs in certain
circumstances.
<br/><br/>
hideOnMaskTap<br/>When using a {@link #cfg!modal} Component, setting this to `true` will hide
the modal mask and the Container when the mask is tapped on.
<br/><br/>
hideShowMenuItem<br/>The {@link Ext.menu.CheckItem} to be used by the owning grid's
header menu to hide or show this column.
<br/><br/>
html<br/>Optional HTML content to render inside this Component, or a reference to an
existing element on the page.
<br/><br/>
id<br/>The **unique id of this component instance.**

It should not be necessary to use this configuration except for singleton objects in
your application. Components created with an id may be accessed globally
using {@link Ext#method!getCmp Ext.getCmp}.

Instead of using assigned ids, use the {@link #cfg!itemId #itemId} config,
and {@link Ext.ComponentQuery} which provides selector-based searching
for Sencha Components analogous to DOM querying. The {@link Ext.Container} class
contains {@link Ext.Container#method!down shortcut methods} to query its descendant Components
by selector.

Note that this id will also be used as the element id for the containing HTML element
that is rendered to the page for this component. This allows you to write id-based CSS
rules to style the specific instance of this component uniquely, and also to select
sub-elements using this component's id as the parent.

**Note**: to avoid complications imposed by a unique id also see `{@link #cfg!itemId #itemId}`.

Defaults to an auto-assigned id.
<br/><br/>
ignore<br/>Setting to `true` prevents this column from being used by plugins such as
{@link Ext.grid.plugin.ViewOptions} or {@link Ext.grid.plugin.Summary}. It is
intended for special columns such as the row number or checkbox selection.
<br/><br/>
ignoreExport<br/>This flag indicates that this column will be ignored when grid data is exported.

When grid data is exported you may want to export only some columns that are
important and not everything. You can set this flag on any column that you want
to be ignored during export.

This is used by {@link Ext.grid.plugin.Exporter}.
<br/><br/>
inactiveChildTabIndex<br/>DOM tabIndex attribute to set on
inactive Focusable children of this container when using the "Roaming tabindex"
technique. This value rarely needs to be changed from its default.
<br/><br/>
innerCls<br/>A string to add to the immediate parent element of the inner items of this
container. That is, items that are not `{@link #cfg!docked docked}`, `{@link #property!positioned positioned}` or `{@link #cfg!floated floated}`. In
some containers, `{@link #property!positioned positioned}` items may be in this same element.
<br/><br/>
instanceCls<br/>
An extra CSS class or classes to augment the {@link #property!classCls #classCls} on an individual instance
<br/><br/>
itemId<br/>An itemId can be used as an alternative way to get a reference to a component when no
object reference is available. Instead of using an `{@link #cfg!id #id}` with {@link Ext#method!getCmp Ext#getCmp},
use `{@link #cfg!itemId itemId}` with {@link Ext.Container#method!getComponent Ext.Container#getComponent} which will retrieve `{@link #cfg!itemId itemId}`'s or
{@link #cfg!id #id}'s. Since `{@link #cfg!itemId itemId}`'s are an index to the container's internal MixedCollection,
the `{@link #cfg!itemId itemId}` is scoped locally to the container - avoiding potential conflicts with
{@link Ext.ComponentManager} which requires a **unique** `{@link #cfg!id #id}`.

Also see {@link #cfg!id #id}, {@link Ext.Container#method!query Ext.Container#query}, {@link Ext.Container#method!down Ext.Container#down} and
{@link Ext.Container#method!child Ext.Container#child}.
<br/><br/>
items<br/>The child items to add to this Container. This is usually an
array of Component configurations or instances, for example:

    @example
    Ext.create({
        xtype: 'container',
        items: [{
            xtype: 'panel',
            html: 'This is an item'
        }]
    });

This may also be specified as an object, the property names of which are `{@link #cfg!itemId itemId}`s, and
the property values are child Component config objects, for example:

    @example
    Ext.create({
        xtype: 'tabpanel',
        items: {
            panel1: {
                xtype: 'panel',
                title: 'First panel'
            },
            panel2: {
                xtype: 'panel',
                title: 'Second panel'
            }
        }
    });
<br/><br/>
keyMap<br/>An object containing handlers for keyboard events. The property names of this
object are the key name and any modifiers. The values of the properties are the
descriptors of how to handle each event.

The handler descriptor can be simply the handler function(either the
literal function or the method name), or it can be an object with these
properties:

 - `handler`: The function or its name to call to handle the event.
 - `scope`: The this pointer context (can be "this" or "controller").
 - `event`: An optional override of the key event to which to listen.

**Important:** Calls to `setKeyMap` do not replace the entire `{@link #cfg!keyMap keyMap}` but
instead update the provided mappings. That is, unless `null` is passed as the
value of the `{@link #cfg!keyMap keyMap}` which will clear the `{@link #cfg!keyMap keyMap}` of all entries.
<br/><br/>
keyMapEnabled<br/>Enables or disables processing keys in the `{@link #cfg!keyMap keyMap}`. This value starts as
`null` and if it is `null` when `{@link #method!initKeyMap initKeyMap}` is called, it will automatically
be set to `true`. Since `{@link #method!initKeyMap initKeyMap}` is called by `{@link Ext.Component}` at the
proper time, this is not something application code normally handles.
<br/><br/>
keyMapTarget<br/>The name of the member that should be used to listen for keydown/keypress events.
This is intended to be controlled at the class level not per instance.
<br/><br/>
layout<br/>Configuration for this Container's layout. Example:

    @example
    Ext.create({
        xtype: 'container',
        layout: {
            type: 'hbox',
            align: 'middle'
        },
        items: [{
            xtype: 'panel',
            flex: 1,
            bodyStyle: {
                background: "#000",
                color:"#fff"
            }
        }, {
           xtype: 'panel',
           flex: 2,
           bodyStyle: {
               background: "#f00",
               color:"#fff"
           }
        }]
    });
<br/><br/>
left<br/>The absolute left position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
<br/><br/>
listeners<br/>
A config object containing one or more event handlers to be added to this object during
initialization. This should be a valid listeners config object as specified in the
{@link Ext.util.Observable#method!addListener addListener} example for attaching
multiple handlers at once.

**DOM events from Ext JS {@link Ext.Component}**

While _some_ Ext JS Component classes export selected DOM events (e.g. "click",
"mouseover" etc), this is usually only done when extra value can be added. For example
the {@link Ext.view.View DataView}'s **`{@link Ext.view.View#itemclick itemclick}`**
event passing the node clicked on. To access DOM events directly from a child element
of a Component, we need to specify the `element` option to identify the Component
property to add a DOM listener to:

    new Ext.panel.Panel({
        width: 400,
        height: 200,
        dockedItems: [{
            xtype: 'toolbar'
        }],
        listeners: {
            click: {
                element: 'el', //bind to the underlying el property on the panel
                fn: function(){ console.log('click el'); }
            },
            dblclick: {
                element: 'body', //bind to the underlying body property on the panel
                fn: function(){ console.log('dblclick body'); }
            }
        }
    });
<br/><br/>
locked<br/>This config can be used with Locking Grid
Determines whether the column is locked or not.
Configure as `true` to lock the column to default locked region
{@link Ext.grid.locked.Grid}
String values contains one of the defined locking regions - "left", "right" or "center"
<br/><br/>
manageBorders<br/>`true` to enable border management of docked items.  When enabled, borders of docked
items will collapse where they meet to avoid duplicated borders.
<br/><br/>
margin<br/>The margin to use on this Component. Can be specified as a number (in which
case all edges get the same margin) or a CSS string like '5 10 10 10'
<br/><br/>
masked<br/>A configuration to allow you to mask this container.

If the value is a string, it will be used as the message config for an
{@link Ext.LoadMask}.

For more precise control over the mask, you can optionally pass an object block with
and xtype of `loadmask`, and an optional `message` value to display a loading mask.
Please refer to the {@link Ext.LoadMask} component to see other configurations.

    @example
    Ext.create({
        xtype: 'container',
        fullscreen: true,
        html: 'Hello World',
        masked: {
            xtype: 'loadmask',
            message: 'My Message'
        }
    });

Alternatively, you can just call the setter at any time with `true`/`false` to show/hide
the mask:

    setMasked(true); //show the mask
    setMasked(false); //hides the mask

There are also two convenient methods, {@link #method!mask #method-mask} and {@link #method!unmask #unmask}, to allow
you to mask and unmask this container at any time.

Remember, the {@link Ext.Viewport} is always a container, so if you want to mask your
whole application at anytime, can call:

    Ext.Viewport.setMasked({
        xtype: 'loadmask',
        message: 'Hello'
    });
<br/><br/>
maxHeight<br/>The maximum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
<br/><br/>
maxWidth<br/>The maximum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size. Note that this config will not apply if the
Component is 'positioned' (absolutely positioned or centered)
<br/><br/>
menu<br/>An optional menu configuration object which is merged with the grid's
{@link #cfg!columnMenu} to create this column's header menu. This can be set
to `null` to remove the menu from this column. To dynamically change whether
the menu should be enabled or not use the `{@link #cfg!menuDisabled menuDisabled}` config.

The grid's {@link Ext.grid.Grid#cfg!columnMenu} provides the sort items, this
config can be used to add column-specific menu items or override aspects of
the common items.
<br/><br/>
menuDisabled<br/>Set to `true` to disable this column's `{@link #cfg!menu menu}` containing sort/hide options.
This can be useful if the menu will be dynamically available since setting
`{@link #cfg!menu menu}` to `null` will eliminate the menu making dynamic changes to its
availability more expensive.
<br/><br/>
minHeight<br/>The minimum height of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
minWidth<br/>The minimum width of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
modal<br/>`true` to make this Component modal. This will create a mask underneath the
Component that covers its parent and does not allow the user to interact with
any other Components until this Component is dismissed.
<br/><br/>
modelValidation<br/>This config enables binding to your `{@link Ext.data.Model#cfg!validators Ext.data.Model#validators}`. This
is only processed by form fields (e.g., `Ext.field.*`) at present, however, this
setting is inherited and so can be set on a parent container.

When set to `true` by a component (or by an ancestor container), the `validators`
of for any {@Ext.data.Model record} fields will be used wherever the `value` is
bound to such data fields.

While this config can be set arbitrarily high in the component hierarchy, doing
so can create a lot overhead if most of your form fields do not actually rely on
`validators` in your data model.

Using this setting for a form that is bound to an `{@link Ext.data.Model}` might look
like this:

     {
         xtype: 'panel',
         modelValidation: true,
         items: [{
             xtype: 'textfield',
             bind: '{theUser.firstName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.lastName}'
         },{
             xtype: 'textfield',
             bind: '{theUser.phoneNumber}'
         },{
             xtype: 'textfield',
             bind: '{theUser.email}'
         }]
     }
<br/><br/>
name<br/>Name for the widget to be used with {@link Ext.Container#method!lookupName Ext.Container#lookupName}
et al.
<br/><br/>
nameable<br/>Set to `true` for this component's `name` property to be tracked by its containing
`nameHolder`.
<br/><br/>
nameHolder<br/>When `true` child components are tracked by their `name` property and can be
retrieved using the `{@link #method!lookupName lookupName}` method.
<br/><br/>
padding<br/>The padding to use on this Component. Can be specified as a number (in which
case all edges get the same padding) or a CSS string like '5 10 10 10'
<br/><br/>
plugins<br/>This config describes one or more plugin config objects used to create plugin
instances for this component.

Plugins are a way to bundle and reuse custom functionality. Plugins should extend
`{@link Ext.plugin.Abstract}` but technically the only requirement for a valid plugin
is that it contain an `init` method that accepts a reference to its owner. Once
a plugin is created, the owner will call the `init` method, passing a reference
to itself. Each plugin can then call methods or respond to events on its owner
as needed to provide its functionality.

This config's value can take several different forms.

The value can be a single string with the plugin's {@link Ext.enums.Plugin alias}:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: 'listpaging'
     });

In the above examples, the string "listpaging" is the type alias for
`{@link Ext.dataview.plugin.ListPaging}`. The full alias includes the "plugin." prefix
(i.e., 'plugin.listpaging').

The preferred form for multiple plugins or to configure plugins is the
keyed-object form (new in version 6.5):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: {
             pullrefresh: true,
             listpaging: {
                 autoPaging: true,
                 weight: 10
             }
         }
     });

The object keys are the `id`'s as well as the default type alias. This form
allows the value of the `{@link #cfg!plugins plugins}` to be merged from base class to derived class
and finally with the instance configuration. This allows classes to define a
set of plugins that derived classes or instantiators can further configure or
disable. This merge behavior is a feature of the
{@link Ext.Class#cfg!config}.

The `{@link #cfg!plugins plugins}` config can also be an array of plugin aliases (arrays are not
merged so this form does not respect plugins defined by the class author):

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: ['listpaging', 'pullrefresh']
     });

An array can also contain elements that are config objects with a `type`
property holding the type alias:

     var list = Ext.create({
         xtype: 'list',
         itemTpl: '&lt;div class="item"&gt;{title}&lt;/div&gt;',
         store: 'Items',

         plugins: ['pullrefresh', {
             type: 'listpaging',
             autoPaging: true
         }]
     });
<br/><br/>
publishes<br/>One or more names of config properties that this component should publish
to its ViewModel. Generally speaking, only properties defined in a class config
block (including ancestor config blocks and mixins) are eligible for publishing
to the viewModel. Some components override this and publish their most useful
configs by default.

**Note:** We'll discuss publishing properties **not** found in the config block below.

Values determined to be invalid by component (often form fields and model validations)
will not be published to the ViewModel.

This config uses the `{@link #cfg!reference #cfg-reference}` to determine the name of the data
object to place in the `ViewModel`. If `{@link #cfg!reference reference}` is not set then this config
is ignored.

By using this config and `{@link #cfg!reference #cfg-reference}` you can bind configs between
components. For example:

     ...
         items: [{
             xtype: 'textfield',
             reference: 'somefield',  // component's name in the ViewModel
             publishes: 'value' // value is not published by default
         },{
             ...
         },{
             xtype: 'displayfield',
             bind: 'You have entered "{somefield.value}"'
         }]
     ...

Classes must provide this config as an Object:

     Ext.define('App.foo.Bar', {
         publishes: {
             foo: true,
             bar: true
         }
     });

This is required for the config system to properly merge values from derived
classes.

For instances this value can be specified as a value as show above or an array
or object as follows:

     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: [
             'value',
             'rawValue',
             'dirty'
         ]
     }

     // This achieves the same result as the above array form.
     {
         xtype: 'textfield',
         reference: 'somefield',
         publishes: {
             value: true,
             rawValue: true,
             dirty: true
         }
     }

In some cases, users may want to publish a property to the viewModel that is not found
in a class  config block. In these situations, you may utilize {@link #method!publishState #publishState}
if the property has a  setter method. Let's use
{@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:

      setFieldLabel: function(fieldLabel) {
          this.callParent(arguments);
          this.publishState('fieldLabel', fieldLabel);
      }

With the above chunk of code, fieldLabel may now be published to the viewModel.
<br/><br/>
record<br/>A model instance which updates the Component's html based on it's tpl. Similar
to the data configuration, but tied to to a record to make allow dynamic
updates.  This must be a model instance and not a configuration of one.
<br/><br/>
reference<br/>Specifies a name for this component inside its component hierarchy. This name
must be unique within its {@link Ext.Container#cfg!referenceHolder view}
or its {@link Ext.app.ViewController}. See the documentation in
{@link Ext.Container Ext.container.Container} for more information about references.

**Note**: Valid identifiers start with a letter or underscore and are followed
by zero or more additional letters, underscores or digits. References are case
sensitive.
<br/><br/>
referenceHolder<br/>If `true`, this container will be marked as being a point in the hierarchy where
references to items with a specified `reference` config will be held. The container
will automatically become a referenceHolder if a {@link #cfg!controller #controller} is specified.

See the introductory docs for {@link Ext.Container Ext.container.Container} for more information
about references &amp; reference holders.
<br/><br/>
relative<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure this as `true` if you require descendant floated components to be positioned
relative to this component's coordinate space, not the viewport's coordinate space.

*Note:* The coordinate space is this Component's encapsulating element's area. Not that
of the inner element in which static child items are rendered by the layout.
<br/><br/>
renderer<br/>A renderer is a method which can be used to transform data (value, appearance, etc.)
before it is rendered.

For example:

     {
         text: 'Some column',
         dataIndex: 'fieldName',

         renderer: function(value, record) {
             if (value === 1) {
                 return '1 person';
             }
             return value + ' people';
         }
     }

If a string is supplied, it should be the name of a renderer method from the
appropriate {@link Ext.app.ViewController}.

This config is only processed if the {@link #cfg!cell #cell} type is the default of
{@link Ext.grid.cell.Cell}.

**Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
to rendering cell content.
<br/><br/>
renderTo<br/>Optional element to render this Component to.
Not required if this component is an {@link Ext.Container#cfg!items item} of a Container
of a Container.
<br/><br/>
reserveScrollbar<br/>Passed in from the owning grid's own configuration
<br/><br/>
resetFocusPosition<br/>When `true`, FocusableContainer
will reset last focused position whenever focus leaves the container.
Subsequent tabbing into the container will always focus the first eligible
child item.

When `false`, subsequent tabbing into the container will focus the child
item that was last focused before.
<br/><br/>
resizable<br/>False to prevent the column from being resizable.
Note that this configuration only works when the
{@link Ext.grid.plugin.ColumnResizing} plugin is enabled on the
{@link Ext.grid.Grid}.
<br/><br/>
right<br/>The absolute right position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
<br/><br/>
ripple<br/>Set to truthy, Color or Object value for the ripple.
<br/><br/>
scope<br/>The scope to use when calling the {@link #cfg!renderer #renderer} or {@link #cfg!formatter #formatter} function.
<br/><br/>
scratchCell<br/><br/><br/>
scrollable<br/>Configuration options to make this Component scrollable. Acceptable values are:

- `true` to enable auto scrolling.
- `false` (or `null`) to disable scrolling - this is the default.
- `{@link #cfg!x x}` or `horizontal` to enable horizontal scrolling only
- `{@link #cfg!y y}` or `vertical` to enable vertical scrolling only

Also accepts a configuration object for a `{@link Ext.scroll.Scroller}` if
if advanced configuration is needed.

The getter for this config returns the {@link Ext.scroll.Scroller}
instance.  You can use the Scroller API to read or manipulate the scroll position:

    // scrolls the component to 5 on the x axis and 10 on the y axis
    component.getScrollable().scrollTo(5, 10);
<br/><br/>
session<br/>If provided this creates a new `Session` instance for this component. If this
is a `Container`, this will then be inherited by all child components.

To create a new session you can specify `true`:

     Ext.create({
         xtype: 'viewport',
         session: true,

         items: [{
             ...
         }]
     });

Alternatively, a config object can be provided:

     Ext.create({
         xtype: 'viewport',
         session: {
             ...
         },

         items: [{
             ...
         }]
     });
<br/><br/>
shadow<br/>Configure as `true` for the component to have a drop shadow. 'false' will suppress any
default shadow. By default the theme will determine the presence of a shadow.
<br/><br/>
shareableName<br/>Set to `true` to allow this component's `name` to be shared by other items in the
same `nameHolder`. Such items will be returned in an array from `lookupName`.
<br/><br/>
shim<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

Configure as `true` for the component to use an `&lt;iframe&gt;` as an underlay to ensure
certain non-standard browser plugins are occluded by this component.
<br/><br/>
showAnimation<br/>Animation effect to apply when the Component is being shown.  Typically you want to use
an inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the
{@link Ext.fx.Animation#cfg!type Ext.fx.Animation#type} config.
<br/><br/>
sortable<br/>False to disable sorting of this column. Whether local/remote sorting is used is
specified in `{@link Ext.data.Store#cfg!remoteSort Ext.data.Store#remoteSort}`.
<br/><br/>
sorter<br/>A sorter config object to apply when the standard sort user interface is
is invoked. This is usually clicking this column header, but there are also
menu options to sort ascending or descending.

Note that a sorter may also be specified as a function which accepts two
records to compare.

A `{@link Ext.app.ViewController}` method can be used like so:

     sorter: 'sorterMethodName'

Or more explicitly:

     sorter: {
         sorterFn: 'sorterMethodName'
     }

By default sorting is based on the `{@link #cfg!dataIndex dataIndex}` but this can be adjusted
like so:

     sorter: {
         property: 'otherProperty'
     }
<br/><br/>
stateful<br/>
This config specifies the config properties that will be persisted using the
{@link Ext.state.Provider}. If this config is set to `true`, the
configs specified by `{@link #cfg!statefulDefaults statefulDefaults}` will be assumed.

     stateful: true

Otherwise, this config can be an array of strings of the properties to save:

     stateful: [
         'width',
         'height',
         'collapsed'
     ]

The above is equivalent to:

     stateful: {
         width: true,
         height: true,
         collapsed: true
     }

**Note:** To be truly stateful, an `id` or `{@link #cfg!stateId stateId}` must also be assigned.

A stateful object will save its state when any of these config properties change
value.
<br/><br/>
statefulDefaults<br/>The default set of {@link #cfg!stateful} properties. The form of this config
is the same as {@link #cfg!stateful} except this config cannot be a Boolean.

This config is intended for classes to specify so that instances can simply
enable statefulness using `stateful: true`.
<br/><br/>
stateId<br/>The unique id for this object to use for state management purposes.
<br/><br/>
style<br/>Additional CSS styles that will be rendered into an inline style attribute when
the widget is rendered.

You can pass either a string syntax:

    style: 'background:red'

Or by using an object:

    style: {
        background: 'red'
    }

When using the object syntax, you can define CSS Properties by using a string:

    style: {
        'border-left': '1px solid red'
    }

Although the object syntax is much easier to read, we suggest you to use the
string syntax for better performance.
<br/><br/>
summary<br/>This config replaces the default mechanism of acquiring a summary result from
the summary record. When specified, this string is the name of a summary type:

 - {@link Ext.data.summary.Average}
 - {@link Ext.data.summary.Count}
 - {@link Ext.data.summary.Max}
 - {@link Ext.data.summary.Min}
 - {@link Ext.data.summary.Sum}

The summary is based on either the {@link #cfg!summaryDataIndex} or the
{@link #cfg!dataIndex} if there is no `{@link #cfg!summaryDataIndex summaryDataIndex}`.

This config is only valid when all data is available client-side to calculate
summaries.

It is generally best to allow the summary {@link Ext.data.Model} to
computer summary values (and not use this config). In some cases, however,
this config can be useful to isolate summary calculations to only certain grids.

To implement a custom summary for a column, use {@link #cfg!summaryRenderer}.
<br/><br/>
summaryCell<br/>The config object used to create {@link Ext.grid.cell.Base} in
{@link Ext.grid.SummaryRow} for this column.
<br/><br/>
summaryDataIndex<br/>For {@link Ext.grid.SummaryRow} this config overrides the normal
`{@link #cfg!dataIndex dataIndex}` to use from the summary record.
<br/><br/>
summaryFormatter<br/>This summaryFormatter is similar to {@link #cfg!formatter #formatter} but is called before
displaying a value in the SummaryRow. The config is optional, if not specified
the default calculated value is shown. The summaryFormatter is called with:

 - value: The calculated value.

Note that this configuration only works when the grid has the
{@link Ext.grid.plugin.Summary} plugin enabled.
<br/><br/>
summaryRenderer<br/>This summaryRenderer is called to render the value to display in a cell of a
summary row. If the value of this config is a String, it is the name of the
renderer method on the associated {@link Ext.Component#cfg!controller controller}.
<br/><br/>
undefined<br/><br/><br/>
tabIndex<br/>DOM tabIndex attribute for this component's
{@link #property!focusEl #focusEl}.
<br/><br/>
text<br/>The header text to be used as innerHTML (html tags are accepted) to display in the
Grid.

**Note**: to have a clickable header with no text displayed you can use the default
non-breaking space (`&amp;nbsp;`).
<br/><br/>
toFrontOnShow<br/>True to automatically call {@link #method!toFront #toFront} when a {@link #cfg!floated #cfg-floated} Component is
shown.
<br/><br/>
toolDefaults<br/>The properties of this object are shallow copied (via {@link Ext#method!applyIf applyIf()}
as opposed to {@link Ext#method!merge Ext.merge()} to each tool declared in the `{@link #cfg!tools tools}`
config.
<br/><br/>
tools<br/>An array of {@link Ext.Tool} configs or an object keyed by `itemId`.
<br/><br/>
tooltip<br/>The tooltip for this component - can be a string to be used as innerHTML
(html tags are accepted) or {@link Ext.tip.ToolTip} config object.

The default behavior is to use a shared tip instance. The tooltip configuration is
registered with the {@link Ext.tip.Manager}. To enable this, your application can set
the {@link Ext.app.Application#cfg!quickTips Ext.app.Application#quickTips} config, or an instance of the
{@link Ext.tip.Manager} may be created manually.

To force a unique tooltip instance to be created, specify `autoCreate: true` on this
configuration.

Configuring this with `autoHide: false` implies `autoCreate: true` so that the desired
persistent behavior can be obtained with other targets still showing the singleton
instance.
<br/><br/>
top<br/>The absolute top position of this Component; must be a valid CSS length value,
e.g: `300`, `100px`, `30%`, etc. Explicitly setting this value will make this Component
become 'positioned', which means it will no longer participate in the layout of the
Container that it resides in.
<br/><br/>
touchAction<br/>
Emulates the behavior of the CSS
[touch-action](https://www.w3.org/TR/pointerevents/#the-touch-action-css-property)
property in a cross-browser compatible manner.

Keys in this object are touch action names, and values are `false` to disable
a touch action or `true` to enable it.  Accepted keys are:

- `panX`
- `panY`
- `pinchZoom`
- `doubleTapZoom`

All touch actions are enabled (`true`) by default, so it is usually only necessary
to specify which touch actions to disable.  For example, the following disables
only horizontal scrolling and pinch-to-zoom on the component's main element:

    touchAction: {
        panX: false,
        pinchZoom: false
    }

Touch actions can be specified on reference elements using the reference element
name, for example:

    // disables horizontal scrolling on the main element, and double-tap-zoom
    // on the child element named "body"
    touchAction: {
        panY: false
        body: {
            doubleTapZoom: false
        }
    }

The primary motivation for setting the touch-action of an element is to prevent
the browser's default handling of a gesture such as pinch-to-zoom, or
drag-to-scroll, so that the application can implement its own handling of that
gesture on the element.  Suppose, for example, a component has a custom drag
handler on its element and wishes to prevent horizontal scrolling of its container
while it is being dragged:

    Ext.create('Ext.Widget', {
        touchAction: {
            panX: false
        },
        listeners: {
            drag: function(e) {
                // implement drag logic
            }
        }
    });
<br/><br/>
tpl<br/>An {@link Ext.XTemplate}, or an XTemplate *definition string* to use
to process a {@link Ext.data.Model} data to produce a cell's rendered
value.

    @example
    Ext.create('Ext.data.Store', {
        storeId:'employeeStore',
        fields:['firstname', 'lastname', 'seniority', 'department'],
        groupField: 'department',
        data:[
            { firstname: "Michael", lastname: "Scott",   seniority: 7, department: "Management" },
            { firstname: "Dwight",  lastname: "Schrute", seniority: 2, department: "Sales" },
            { firstname: "Jim",     lastname: "Halpert", seniority: 3, department: "Sales" },
            { firstname: "Kevin",   lastname: "Malone",  seniority: 4, department: "Accounting" },
            { firstname: "Angela",  lastname: "Martin",  seniority: 5, department: "Accounting" }
        ]
    });

    Ext.create('Ext.grid.Panel', {
        title: 'Column Template Demo',
        store: Ext.data.StoreManager.lookup('employeeStore'),
        columns: [{
            text: 'Full Name',
            tpl: '{firstname} {lastname}'
        }, {
            text: 'Department (Yrs)',
            tpl: '{department} ({seniority})'
        }],
        height: 200,
        width: 300,
        renderTo: Ext.getBody()
    });

This config is only processed if the {@link #cfg!cell #cell} type is the default of
{@link Ext.grid.cell.Cell}.

**Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
to rendering cell content.
<br/><br/>
tplWriteMode<br/>The Ext.(X)Template method to use when updating the content area of the
Component.

Valid modes are:

- append
- insertAfter
- insertBefore
- insertFirst
- overwrite
<br/><br/>
translatable<br/><br/><br/>
twoWayBindable<br/>This object holds a map of `config` properties that will update their binding
as they are modified. For example, `value` is a key added by form fields. The
form of this config is the same as `{@link #cfg!publishes}`.

This config is defined so that updaters are not created and added for all
bound properties since most cannot be modified by the end-user and hence are
not appropriate for two-way binding.
<br/><br/>
ui<br/>The ui or uis to be used on this Component

When a ui is configured, CSS class names are added to the {@link #property!element #element}, created
by appending the ui name(s) to each {@link #property!classCls #classCls} and/or {@link #property!baseCls #baseCls}.
<br/><br/>
userCls<br/>One or more CSS classes to add to the component's primary element. This config
is intended solely for use by the component instantiator (the "user"), not by
derived classes.

For example:

     items: [{
         xtype: 'button',
         userCls: 'my-button'
     ...
     }]
<br/><br/>
userSelectable<br/>
Set to true to allow users to select text within this component.

Can also be any valid value for the CSS3
[user-select](https://developer.mozilla.org/en-US/docs/Web/CSS/user-select) property.

A value of true implies `auto`, while false implies `none`.

May also be an object keyed by child element name.

By default, the user cannot click+drag+select text/elements of the UI.  Applications may
want to enable user selection for specific DOM elements, such as the bodyElement of
a component used as a tab panel.  The tab and tab text would not be user selectable in
this example, but the content area when the tab is selected would.

     userSelectable: {
         element: true,       // allow the element to be user selectable
         bodyElement: true    // allow the component's body element to be user selectable
     }
<br/><br/>
verticalOverflow<br/>Updated by the grid to inform the header container whether it must account for a
vertical scrollbar.
<br/><br/>
viewModel<br/>The `ViewModel` is a data provider for this component and its children. The
data contained in the `ViewModel` is typically used by adding `{@link #cfg!bind bind}` configs
to the components that want present or edit this data.

When set, the `ViewModel` is created and links to any inherited `{@link #cfg!viewModel viewModel}`
instance from an ancestor container as the "parent". The `ViewModel` hierarchy,
once established, only supports creation or destruction of children. The
parent of a `ViewModel` cannot be changed on the fly.

If this is a root-level `ViewModel`, the data model connection is made to this
component's associated `{@link Ext.data.Session}`. This is
determined by calling `getInheritedSession`.
<br/><br/>
weight<br/>This value controls this item's order in a {@link Ext.Container#cfg!weighted}
{@link Ext.Container} (see {@link #cfg!parent}).

Lower values gravitate towards the start of the container - the top in vertical layouts,
the locale start side in horizontal layouts.
<br/><br/>
weighted<br/>If set to `true`, then child {@link #cfg!items} may be specified as a object,
with each property name specifying an {@link #cfg!itemId}, and the property
value being the child item configuration object.

When using this scheme, each child item may contain a {@link #cfg!weight}
configuration value which affects its order in this container. Lower weights
are towards the start, higher weights towards the end.
<br/><br/>
width<br/>The width of this Component; must be a valid CSS length value, e.g: `300`, `100px`,
`30%`, etc. By default, if this is not explicitly set, this Component's element will
simply have its own natural size. If set to `auto`, it will set the width to `null`
meaning it will have its own natural size.
<br/><br/>
x<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
<br/><br/>
xtype<br/>The `{@link #cfg!xtype xtype}` configuration option can be used to optimize Component creation and rendering.
It serves as a shortcut to the full component name. For example, the component
`Ext.button.Button` has an xtype of `button`.

You can define your own xtype on a custom {@link Ext.Component} like so:

    Ext.define('PressMeButton', {
        extend: 'Ext.button.Button',
        xtype: 'pressmebutton',
        text: 'Press Me'
    });

Any Component can be created implicitly as an object config with an xtype specified,
allowing it to be declared and passed into the rendering pipeline without actually being
instantiated as an object. Not only is rendering deferred, but the actual creation of the
object itself is also deferred, saving memory and resources until they are actually needed.
In complex, nested layouts containing many Components, this can make a noticeable
improvement in performance.

    // Explicit creation of contained Components:
    var panel = new Ext.Panel({
       // ...
       items: [
          Ext.create('Ext.button.Button', {
             text: 'OK'
          })
       ]
    });

    // Implicit creation using xtype:
    var panel = new Ext.Panel({
       // ...
       items: [{
          xtype: 'button',
          text: 'OK'
       }]
    });

In the first example, the button will always be created immediately during the panel's
initialization. With many added Components, this approach could potentially slow the
rendering of the page. In the second example, the button will not be created or rendered
until the panel is actually displayed in the browser. If the panel is never displayed
(for example, if it is a tab that remains hidden) then the button will never be created and
will never consume any resources whatsoever.
<br/><br/>
y<br/>*Only valid when a component is `{@link #cfg!floated #cfg-floated}`*

The x position at which to position this component. This is usually viewport-relative.
But if there is a `{@link #cfg!relative #relative}: true` ancestor, it will be relative to that.
<br/><br/>
zIndex<br/>The z-index to give this Component when it is rendered.

Not valid for {@link #cfg!floated #cfg-floated} Components. The Z ordering of {@link #cfg!floated #cfg-floated}
Components is managed by ordering of the DOM elements.
<br/><br/>

            </div>
        </z-tabpanel>
        <z-tabpanel tabname="methods">
            <div class="flex-container">
                methoda
            </div>
        </z-tabpanel>

        <z-tabpanel tabname="events">
            <div class="flex-container">
                onActivate = ( {detail: { newActiveItem, sender, oldActiveItem }} ) => {}<br/>
onActiveItemchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onAdd = ( {detail: { sender, item, index }} ) => {}<br/>
onAdded = ( {detail: { sender, container, index }} ) => {}<br/>
onBeforeactiveItemchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforebottomchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforecenteredchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforedisabledchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforedockedchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeheightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforehiddenchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforehide = ( {detail: { sender }} ) => {}<br/>
onBeforeleftchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforemaxHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforemaxWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeminHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeminWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeorientationchange = ( {detail: {  }} ) => {}<br/>
onBeforerightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforescrollablechange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforeshow = ( {detail: { sender }} ) => {}<br/>
onBeforetofront = ( {detail: { sender }} ) => {}<br/>
onBeforetopchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBeforewidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onBlur = ( {detail: { sender, event }} ) => {}<br/>
onBottomchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onCenteredchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onDeactivate = ( {detail: { oldActiveItem, sender, newActiveItem }} ) => {}<br/>
onDestroy = ( {detail: {  }} ) => {}<br/>
onDisabledchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onDockedchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onErased = ( {detail: { sender }} ) => {}<br/>
onFloatingchange = ( {detail: { sender, positioned }} ) => {}<br/>
onFocus = ( {detail: { sender, event }} ) => {}<br/>
onFocusenter = ( {detail: { sender, event }} ) => {}<br/>
onFocusleave = ( {detail: { sender, event }} ) => {}<br/>
onFullscreen = ( {detail: { sender }} ) => {}<br/>
onHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onHiddenchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onHide = ( {detail: { sender }} ) => {}<br/>
onInitialize = ( {detail: { sender }} ) => {}<br/>
onLeftchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onMaxHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onMaxWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onMinHeightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onMinWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onMove = ( {detail: { sender, item, toIndex, fromIndex }} ) => {}<br/>
onMoved = ( {detail: { sender, container, toIndex, fromIndex }} ) => {}<br/>
onOrientationchange = ( {detail: {  }} ) => {}<br/>
onPainted = ( {detail: { sender, element }} ) => {}<br/>
onPositionedchange = ( {detail: { sender, positioned }} ) => {}<br/>
onRemove = ( {detail: { sender, item, index }} ) => {}<br/>
onRemoved = ( {detail: { sender, container, index }} ) => {}<br/>
onRenderedchange = ( {detail: { sender, item, rendered }} ) => {}<br/>
onResize = ( {detail: { element, info }} ) => {}<br/>
onRightchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onScrollablechange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onShow = ( {detail: { sender }} ) => {}<br/>
onTofront = ( {detail: { sender }} ) => {}<br/>
onTopchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>
onUpdatedata = ( {detail: { sender, newData }} ) => {}<br/>
onWidthchange = ( {detail: { sender, value, oldValue }} ) => {}<br/>

            </div>
        </z-tabpanel>

        <z-tabpanel tabname="React">
            <div class="flex-container">

            </div>
        </z-tabpanel>


        <z-tabpanel tabname="Web Components">
            <div class="flex-container">

            </div>
        </z-tabpanel>


    </z-tabs>



    </section>






</div>


</body>
</html>